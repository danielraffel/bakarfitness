<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Plan your rooftop swim at Bakar Fitness Center at UCSF Mission Bay with real-time weather updates. Get temperature, wind speed, and precipitation forecasts to pick the best times to swim today, avoiding unfavorable conditions like wind or rain." />
    <title>Best Time to Swim at Bakar Fitness Center at UCSF Mission Bay Today</title>
    <!-- Primary PNG Favicon (128x128, with cache bypass) -->
    <link rel="icon" type="image/png" sizes="128x128" href="https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-12/128/man-swimming.png?v=1">
    <!-- SVG Favicon for Modern Browsers -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèä</text></svg">    
    <!-- Apple Touch Icons (with cache bypass) -->
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/danielraffel/bakarfitness/main/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-12/256/man-swimming.png?v=1">
    <link rel="apple-touch-icon" sizes="256x256" href="https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-12/256/man-swimming.png?v=1">
    <link rel="apple-touch-icon" sizes="128x128" href="https://s3.amazonaws.com/pix.iemoji.com/images/emoji/apple/ios-12/128/man-swimming.png?v=1">
    <!-- iOS Web App Configuration -->
    <meta name="apple-mobile-web-app-title" content="Best Time for Athletes to Swim Today">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <!-- External CSS and JS libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
    <style>
        /* Animation for blinking effect */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-blink {
            animation: blink 0.5s ease-in-out 3;
        }

        /* Night mode styles */
        body.night-mode {
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        body.night-mode .bg-white {
            background-color: #2a2a2a;
        }

        body.night-mode .bg-gray-50 {
            background-color: #333333;
            color: #f0f0f0;
        }

        body.night-mode .bg-gray-100 {
            background-color: #3a3a3a;
        }

        body.night-mode .hover\:bg-gray-100:hover {
            background-color: #444444;
        }

        body.night-mode input,
        body.night-mode select {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border-color: #4a4a4a;
        }

        body.night-mode .shadow-md {
            box-shadow: 0 4px 6px -1px rgba(255, 255, 255, 0.1), 0 2px 4px -1px rgba(255, 255, 255, 0.06);
        }

        body.night-mode .text-gray-500 {
            color: #aaaaaa;
        }
        
        body.night-mode .text-gray-600 {
            color: #cccccc;
        }

        @media (max-width: 640px) {
            #mobile-legend {
                display: flex;
                justify-content: space-between;
                margin-bottom: 0.5rem;
                font-size: 0.65rem;
            }

            #mobile-legend .flex {
                align-items: center;
                margin-right: 0.25rem;
            }

            #mobile-legend .rounded-full {
                width: 0.6rem;
                height: 0.6rem;
                margin-right: 0.15rem;
            }

            #best-swim-time .flex {
                flex-direction: row;
            }
            #best-swim-time .w-full {
                width: 50%;
            }
            #best-swim-time h3 {
                font-size: 1rem;
            }
            #best-swim-time ul {
                font-size: 0.875rem;
            }

            .chart-wrapper {
                max-height: 250px !important;
            }
            
            #weather-calendar {
                font-size: 0.9rem;
            }
        }
    </style>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-4 sm:py-8">
        <h1 class="text-3xl font-bold mb-6 text-center">Best Time to Swim at Bakar Fitness</h1>
        
        <!-- Swimming on the Roof at Bakar Fitness information -->
        <div id="swimming-info" class="bg-white shadow-md rounded-lg p-6 mb-4 sm:mb-6">
            <h2 class="text-1xl font-semibold mb-2 sm:mb-4">Swimming on the Roof at Bakar Fitness</h2>
            
            <!-- Date selector -->
            <div class="flex items-center space-x-2 sm:space-x-4 mb-2 sm:mb-4">
                <span>Date:</span>
                <input type="date" id="date-picker" class="border rounded px-2 py-1">
                <span id="day-of-week" class="text-gray-600"></span>
            </div>
            
            <div class="flex items-center space-x-2 sm:space-x-4 mb-2 sm:mb-4">
                <span>in</span>
                <!-- Desktop view for time difference input -->
                <input type="text" id="swimming-time-diff" class="border rounded px-2 py-1 w-20 hidden sm:inline">
                <!-- Mobile view for time difference input -->
                <div class="flex space-x-1 sm:hidden">
                    <select id="swimming-hours" class="border rounded px-1 py-1 w-16">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                    <select id="swimming-minutes" class="border rounded px-1 py-1 w-[4.5rem]">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <span>at</span>
                <div class="relative">
                    <input type="time" id="swimming-time" class="border rounded px-2 py-1">
                    <div id="swimming-time-blink" class="absolute inset-0 bg-yellow-200 opacity-0 pointer-events-none"></div>
                </div>
            </div>
            <div id="swimming-weather" class="text-lg"></div>
        </div>

        <!-- Best Swim Time section -->
        <div id="best-swim-time" class="bg-white shadow-md rounded-lg p-6 mt-4 sm:mt-6">
            <div class="flex flex-col sm:flex-row justify-between">
                <div class="w-full sm:w-1/2 pr-0 sm:pr-2 mb-4 sm:mb-0">
                    <h3 class="text-lg font-semibold mb-2 text-yellow-500">
                        ü•á <span class="sm:hidden">Best time</span><span class="hidden sm:inline">Best time to Swim</span>
                    </h3>
                    <ul id="best-time-info-1" class="text-base list-none p-0"></ul>
                </div>
                <div class="w-full sm:w-1/2 pl-0 sm:pl-2">
                    <h3 class="text-lg font-semibold mb-2 text-gray-500">
                        ü•à <span class="sm:hidden">Second best</span><span class="hidden sm:inline">Second Best time to Swim</span>
                    </h3>
                    <ul id="best-time-info-2" class="text-base list-none p-0"></ul>
                </div>
            </div>
        </div>

        <!-- Weather Chart container -->
        <div class="chart-container bg-white shadow-md rounded-lg p-6 mt-4 sm:mt-6">
            <h2 class="text-1xl font-semibold mb-4"><span id="forecast-title">Today's Weather Forecast</span></h2>
            <!-- Mobile legend -->
            <div id="mobile-legend" class="md:hidden flex flex-wrap justify-around text-xs mb-2">
                <div class="flex items-center mr-2 mb-1">
                    <span class="w-3 h-3 rounded-full bg-red-400 mr-1"></span>
                    <span>Temp (¬∞F)</span>
                </div>
                <div class="flex items-center mr-2 mb-1">
                    <span class="w-3 h-3 rounded-full bg-blue-400 mr-1"></span>
                    <span>Cloud (%)</span>
                </div>
                <div class="flex items-center mr-2 mb-1">
                    <span class="w-3 h-3 rounded-full bg-green-400 mr-1"></span>
                    <span>Wind (MPH)</span>
                </div>
                <div class="flex items-center mb-1">
                    <span class="w-3 h-3 rounded-full bg-purple-400 mr-1"></span>
                    <span>Precip (%)</span>
                </div>
            </div>
            <div class="chart-wrapper" style="position: relative; height: 40vh; max-height: 300px;">
                <canvas id="weatherChart"></canvas>
            </div>
        </div>
        
        <!-- 16-Day Weather Calendar -->
        <div class="calendar-container bg-white shadow-md rounded-lg p-6 mt-4 sm:mt-6">
            <h2 class="text-1xl font-semibold mb-4">16-Day Weather Forecast</h2>
            <div id="weather-calendar" class="grid grid-cols-4 sm:grid-cols-7 md:grid-cols-8 gap-2"></div>
        </div>
    </div>
    
    <div>
        <div class="text-sm sm:mt-0 mt-2 sm:mb-6 mb-0 text-center">
            <a href="https://github.com/danielraffel/bakarfitness" target="_blank" style="text-decoration: underline;">About this Site</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script>
        // Helper functions
        
        function getSwimmingTimeDiff() {
            return localStorage.getItem('swimmingTimeDiff_bakar') || '0h0m';
        }

        function setSwimmingTimeDiff(value) {
            localStorage.setItem('swimmingTimeDiff_bakar', value);
        }

        function normalizeTimeDiff(value) {
            if (/^(0|0[hm]|0h0m)$/.test(value)) {
                return '0h0m';
            }
            const match = value.match(/^(\d+)(?:h|m)?(\d+)?m?$/);
            if (match) {
                const hours = parseInt(match[1]);
                const minutes = match[2] ? parseInt(match[2]) : 0;
                if (match[0].includes('h') || (!match[0].includes('h') && !match[0].includes('m') && hours >= 60)) {
                    return `${hours}h${minutes}m`;
                } else {
                    return `${hours}m`;
                }
            }
            return value;
        }

        function parseTimeDiff(timeDiff) {
            if (timeDiff === '0' || timeDiff === '0h' || timeDiff === '0m' || timeDiff === '0h0m') {
                return 0;
            }
            const match = timeDiff.match(/^(\d+)(?:h|m)?(\d+)?m?$/);
            if (match) {
                const firstNumber = parseInt(match[1]);
                const secondNumber = match[2] ? parseInt(match[2]) : 0;
                if (match[0].includes('h') || (!match[0].includes('h') && !match[0].includes('m') && firstNumber >= 60)) {
                    return firstNumber * 60 + secondNumber;
                } else {
                    return firstNumber;
                }
            }
            return 0;
        }

        function formatTimeDiff(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            if (hours === 0 && mins === 0) return '0h0m';
            if (hours === 0) return `${mins}m`;
            if (mins === 0) return `${hours}h`;
            return `${hours}h${mins}m`;
        }

        function addMinutesToDate(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }

        function getMinutesBetweenDates(date1, date2) {
            return Math.round((date2 - date1) / 60000);
        }

        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function formatDateTime(date) {
            return date.toLocaleString('en-US', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit', 
                hour12: true 
            });
        }

        // Format date as YYYY-MM-DD
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Get day of week
        function getDayOfWeek(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days[date.getDay()];
        }

        // Format date for display
        function formatDateForDisplay(date) {
            const dayOfWeek = getDayOfWeek(date);
            const month = date.toLocaleString('default', { month: 'long' });
            const day = date.getDate();
            
            // Get year for display in the chart title
            const year = date.getFullYear();
            
            return `${dayOfWeek}, ${month} ${day} Weather Forecast`;
        }

        // DOM elements
        const swimmingTimeDiff = document.getElementById('swimming-time-diff');
        const swimmingTime = document.getElementById('swimming-time');
        const swimmingWeather = document.getElementById('swimming-weather');
        const swimmingHoursSelect = document.getElementById('swimming-hours');
        const swimmingMinutesSelect = document.getElementById('swimming-minutes');
        const datePicker = document.getElementById('date-picker');
        const dayOfWeekElement = document.getElementById('day-of-week');
        const forecastTitle = document.getElementById('forecast-title');

        // Track selected date
        let selectedDate = new Date();
        
                        function initializePage() {
            // Get the current date from the browser
            const now = new Date();
            
            // Create a clean date at midnight to avoid time-related issues
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            today.setHours(0, 0, 0, 0); // Set to beginning of day for consistent comparisons
            
            console.log("Initializing page with browser date:", now);
            console.log("Cleaned today date:", today);
            
            // Initialize date picker with today's date
            const todayFormatted = formatDate(today);
            datePicker.value = todayFormatted;
            dayOfWeekElement.textContent = getDayOfWeek(today);
            
            // Set the selected date to today properly
            selectedDate = new Date(today);
            
            // Set maximum date (16 days from now - the API limit)
            const maxDate = new Date(today);
            maxDate.setDate(maxDate.getDate() + 15); // 16-day forecast (0-15)
            datePicker.max = formatDate(maxDate);
            
            // Set minimum date (today)
            datePicker.min = todayFormatted;
            
            // Get the stored time diff or use '0h0m' as default
            const storedTimeDiff = getSwimmingTimeDiff();
            swimmingTimeDiff.value = storedTimeDiff;

            // Set the swimming time based on the stored time diff
            const swimMinutes = parseTimeDiff(storedTimeDiff);
            const currentTime = new Date();
            const swimAt = new Date(currentTime.getTime() + swimMinutes * 60000);
            swimmingTime.value = formatTime(swimAt);

            // Populate dropdowns
            populateDropdowns(swimmingHoursSelect, swimmingMinutesSelect);

            // Set mobile dropdowns based on stored time diff
            const hours = Math.floor(swimMinutes / 60);
            const minutes = swimMinutes % 60;
            swimmingHoursSelect.value = hours.toString();
            swimmingMinutesSelect.value = minutes.toString();

            // Force an update of all related information
            updateSwimmingInfo();

            // Explicitly update weather for current time
            updateWeather(swimAt);

            // Call other initialization functions
            fetchWeatherData(formatDate(selectedDate));
            
            // Update all forecast date information for consistency
            updateForecastDateInfo();
        }

        function updateSwimmingInfo() {
            const now = new Date();
            let swimMinutes = parseTimeDiff(swimmingTimeDiff.value);
            
            // Use the selected date instead of today for the target time
            let swimAt = new Date(selectedDate);
            
            // If selected date is today, apply the time difference from now
            if (formatDate(selectedDate) === formatDate(now)) {
                swimAt = new Date(now.getTime() + swimMinutes * 60000);
                
                // Ensure swimAt is not before now
                if (swimAt < now) {
                    provideFeedback(swimmingTime);
                    swimAt = new Date(now);
                }
            } else {
                // For future dates, use the specified time from swimmingTime input
                const [hours, minutes] = swimmingTime.value.split(':');
                swimAt.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            }

            // Ensure swimAt is not after 11:59 PM on the selected date
            const endOfSelectedDay = new Date(selectedDate);
            endOfSelectedDay.setHours(23, 59, 0, 0);
            
            if (swimAt > endOfSelectedDay) {
                provideFeedback(swimmingTime);
                swimAt = new Date(endOfSelectedDay);
            }

            // Update the time input to reflect the actual time
            swimmingTime.value = formatTime(swimAt);
            
            // If selected date is today, update the time diff
            if (formatDate(selectedDate) === formatDate(now)) {
                swimMinutes = getMinutesBetweenDates(now, swimAt);
                swimmingTimeDiff.value = normalizeTimeDiff(formatTimeDiff(swimMinutes));
            }

            updateAllInputs();
            updateWeather(swimAt);
        }

        function handleSwimmingTimeChange() {
            const [hours, minutes] = swimmingTime.value.split(':');
            
            // Create a new date with the selected date and specified time
            let swimAt = new Date(selectedDate);
            swimAt.setHours(parseInt(hours), parseInt(minutes), 0, 0);

            const now = new Date();
            
            // Ensure swimAt is not before now if the selected date is today
            if (formatDate(selectedDate) === formatDate(now) && swimAt < now) {
                provideFeedback(swimmingTime);
                swimAt = new Date(now);
                swimmingTime.value = formatTime(swimAt);
            }

            // If selected date is today, calculate minutes from now
            if (formatDate(selectedDate) === formatDate(now)) {
                let swimMinutes = getMinutesBetweenDates(now, swimAt);
                const timeDiffValue = formatTimeDiff(swimMinutes);
                swimmingTimeDiff.value = timeDiffValue;
                setSwimmingTimeDiff(timeDiffValue);
            }

            updateSwimmingInfo();
        }

        function handleDateChange() {
            // Parse the date value properly to avoid timezone issues
            // Format is YYYY-MM-DD from the date picker
            const [year, month, day] = datePicker.value.split('-').map(Number);
            
            // Create date using year, month (0-indexed), day to avoid timezone issues
            selectedDate = new Date(year, month - 1, day);
            
            console.log("Date changed to:", selectedDate.toDateString(), "Date value:", datePicker.value);
            
            // Update the day of week display
            dayOfWeekElement.textContent = getDayOfWeek(selectedDate);
            
            // Update the forecast title
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Set to beginning of day
            
            if (formatDate(selectedDate) === formatDate(today)) {
                forecastTitle.textContent = "Today's Weather Forecast";
            } else {
                forecastTitle.textContent = formatDateForDisplay(selectedDate);
            }
            
            // Fetch weather data for the selected date
            fetchWeatherData(formatDate(selectedDate));
            
            // Update swimming info for the new date
            updateSwimmingInfo();
            
            // Highlight selected day in calendar - use the date value directly
            highlightSelectedDayInCalendar(datePicker.value);
            
            // Update best swim time display with selected date info
            updateBestSwimTimeDisplay(selectedDate);
            
            // Dispatch a custom event that other components can listen for
            const event = new CustomEvent('dateselectedbyuser', { 
                detail: { 
                    date: datePicker.value,
                    dateObj: selectedDate
                } 
            });
            window.dispatchEvent(event);
        }
        
        function updateBestSwimTimeDisplay(date) {
            // This ensures the best swim time displays reflect the correct date
            // even if the actual data hasn't been fetched yet
            const bestTimeHeaders = document.querySelectorAll('#best-time-info-1 li:first-child, #best-time-info-2 li:first-child');
            
            // Only update if there are existing best time elements
            bestTimeHeaders.forEach(header => {
                // Extract the time part and update the date part
                const timeMatch = header.textContent.match(/(.*?)(Today|Tomorrow|on .+)$/);
                if (timeMatch) {
                    const timePart = timeMatch[1].trim();
                    
                    // Determine date descriptor (Today, Tomorrow, or date)
                    const today = new Date();
                    const tomorrow = new Date(today);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    
                    let dateDesc;
                    if (formatDate(date) === formatDate(today)) {
                        dateDesc = 'Today';
                    } else if (formatDate(date) === formatDate(tomorrow)) {
                        dateDesc = 'Tomorrow';
                    } else {
                        const month = date.toLocaleString('default', { month: 'short' });
                        const day = date.getDate();
                        dateDesc = `on ${month} ${day}`;
                    }
                    
                    header.textContent = `${timePart} ${dateDesc}`;
                }
            });
        }
        
        function highlightSelectedDayInCalendar(specificDate = null) {
            // Remove highlighting from all cells
            const calendarCells = document.querySelectorAll('#weather-calendar > div');
            const today = new Date();
            const todayStr = formatDate(today);
            const dateToHighlight = specificDate || formatDate(selectedDate);
            
            console.log("Highlighting date:", dateToHighlight, "Today is:", todayStr);
            
            calendarCells.forEach(cell => {
                // Reset all cells first
                cell.classList.remove('border-2', 'border-green-500', 'border-blue-500');
                
                // If this is today's cell
                if (cell.dataset.date === todayStr) {
                    // Only add blue border if it's not the selected date
                    if (cell.dataset.date !== dateToHighlight) {
                        cell.classList.add('border-2', 'border-blue-500');
                    }
                }
            });
            
            // Add highlighting to selected cell
            const selectedCell = Array.from(calendarCells).find(
                cell => cell.dataset.date === dateToHighlight
            );
            
            if (selectedCell) {
                selectedCell.classList.add('border-2', 'border-green-500');
                
                // Scroll to make selected cell visible if needed
                selectedCell.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Event listeners
        swimmingTimeDiff.addEventListener('change', () => {
            setSwimmingTimeDiff(swimmingTimeDiff.value);
            updateSwimmingInfo();
        });

        swimmingTime.addEventListener('change', handleSwimmingTimeChange);

        swimmingHoursSelect.addEventListener('change', handleMobileSwimmingChange);
        swimmingMinutesSelect.addEventListener('change', handleMobileSwimmingChange);

        datePicker.addEventListener('change', handleDateChange);

        // Remove any previous initialization calls
        document.removeEventListener('DOMContentLoaded', initializePage);

        // Consolidated initialization into a single DOM content loaded event listener
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded, initializing page with current timezone:", Intl.DateTimeFormat().resolvedOptions().timeZone);
            console.log("Current date:", new Date().toDateString());
            
            initializePage();
            applyTheme();
            startWeatherUpdate();
            
            // Fetch forecast data with explicit today filtering
            setTimeout(() => {
                fetch16DayForecast();
            }, 500); // Larger delay to ensure other initialization is complete
            
            // Set up the image update if the element exists
            const ggbImage = document.getElementById('ggb-image');
            if (ggbImage) {
                ggbImage.onload = updateGGBImage;
                setInterval(updateGGBImage, 30 * 1000);
            }
            
            // Set up automatic update of date related info every 30 seconds
            // This ensures everything stays in sync
            setInterval(updateForecastDateInfo, 30000);
        });

        function updateForecastDateInfo() {
            // Synchronize all date-related info on the page
            const currentDate = selectedDate || new Date();
            
            // Update date picker
            datePicker.value = formatDate(currentDate);
            
            // Update day of week
            dayOfWeekElement.textContent = getDayOfWeek(currentDate);
            
            // Update the forecast title
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Set to beginning of day
            
            if (formatDate(currentDate) === formatDate(today)) {
                forecastTitle.textContent = "Today's Weather Forecast";
            } else {
                forecastTitle.textContent = formatDateForDisplay(currentDate);
            }
            
            // Highlight the correct calendar date
            highlightSelectedDayInCalendar(formatDate(currentDate));
            
            // Update best swim time display
            updateBestSwimTimeDisplay(currentDate);
        }
        
        // Listen for clicks on calendar day cells
        document.addEventListener('click', function(event) {
            // Find if a calendar cell was clicked
            let calendarCell = null;
            let target = event.target;
            
            // Traverse up to find the calendar cell
            while (target && target !== document) {
                if (target.parentElement && target.parentElement.id === 'weather-calendar') {
                    calendarCell = target;
                    break;
                }
                target = target.parentElement;
            }
            
            // If a calendar cell was clicked and it has a date
            if (calendarCell && calendarCell.dataset.date) {
                console.log("Calendar cell clicked with date:", calendarCell.dataset.date);
                
                // Update the date picker
                datePicker.value = calendarCell.dataset.date;
                
                // Trigger the date change handler
                handleDateChange();
            }
        });

        // Main logic functions
        
        function updateSingleInput(timeDiffInput, hoursSelect, minutesSelect) {
            const hours = parseInt(hoursSelect.value);
            const minutes = parseInt(minutesSelect.value);
            const value = formatTimeDiff(hours * 60 + minutes);
            timeDiffInput.value = value;
            
            setSwimmingTimeDiff(value);
            updateSwimmingInfo();
        }

        function populateDropdowns(hoursSelect, minutesSelect) {
            hoursSelect.innerHTML = '';
            minutesSelect.innerHTML = '';

            for (let i = 0; i < 24; i++) {
                hoursSelect.innerHTML += `<option value="${i}">${i}h</option>`;
            }

            for (let i = 0; i < 60; i++) {
                minutesSelect.innerHTML += `<option value="${i}">${i.toString().padStart(2, '0')}m</option>`;
            }
        }

        function updateDropdowns(timeDiffInput, hoursSelect, minutesSelect) {
            const minutes = parseTimeDiff(timeDiffInput.value);
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            hoursSelect.value = hours;
            minutesSelect.value = mins;
        }

        async function updateWeather(specificTime = null) {
            const weatherInfo = swimmingWeather;

            try {
                const now = new Date();
                let targetTime = specificTime ? new Date(specificTime) : new Date(selectedDate);
                
                if (!specificTime) {
                    const [hours, minutes] = swimmingTime.value.split(':');
                    targetTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                }

                // Format the date for the API request
                const formattedDate = formatDate(targetTime);

                // Round the target time to the nearest hour
                const roundedTime = new Date(targetTime.getFullYear(), targetTime.getMonth(), targetTime.getDate(), targetTime.getHours() + Math.round(targetTime.getMinutes() / 60));
                const apiTimeString = roundedTime.toISOString().slice(0, 16);

                // Updated coordinates for Mission Bay, San Francisco
                const response = await axios.get(`https://api.open-meteo.com/v1/forecast?latitude=37.7749&longitude=-122.3890&hourly=temperature_2m,windspeed_10m,precipitation_probability&timezone=America/Los_Angeles&start_date=${formattedDate}&end_date=${formattedDate}&temperature_unit=fahrenheit`);

                const data = response.data;

                const hourIndex = targetTime.getHours();

                const temperature = data.hourly.temperature_2m[hourIndex];
                const windSpeed = data.hourly.windspeed_10m[hourIndex];
                const precipitationProbability = data.hourly.precipitation_probability[hourIndex];

                weatherInfo.innerHTML = `
                    <p>Temperature: ${temperature.toFixed(1)}¬∞F</p>
                    <p>Wind Speed: ${(windSpeed * 0.621371).toFixed(1)} mph</p>
                    <p>Precipitation Probability: ${precipitationProbability}%</p>
                `;
            } catch (error) {
                console.error(`Error fetching weather data:`, error);
                weatherInfo.innerHTML = '<p>Unable to fetch weather data. Please try again later.</p>';
            }
        }

        function startWeatherUpdate() {
            setInterval(() => {
                updateWeather();
            }, 60000); // Update every minute
        }

        function handleMobileSwimmingChange() {
            const hours = parseInt(swimmingHoursSelect.value);
            const minutes = parseInt(swimmingMinutesSelect.value);
            const value = formatTimeDiff(hours * 60 + minutes);
            swimmingTimeDiff.value = value;
            setSwimmingTimeDiff(value);
            updateSwimmingInfo();
        }

        // Event listeners for mobile inputs
        swimmingHoursSelect.addEventListener('change', handleMobileSwimmingChange);
        swimmingMinutesSelect.addEventListener('change', handleMobileSwimmingChange);

        function updateMobileInputs() {
            const swimmingMinutes = parseTimeDiff(swimmingTimeDiff.value);
            const hours = Math.floor(swimmingMinutes / 60);
            const minutes = swimmingMinutes % 60;
            swimmingHoursSelect.value = hours;
            swimmingMinutesSelect.value = minutes;
        }

        function updateAllInputs() {
            updateMobileInputs();
            
            // Only update swimming time based on time diff if the selected date is today
            const now = new Date();
            if (formatDate(selectedDate) === formatDate(now)) {
                swimmingTime.value = formatTime(addMinutesToDate(now, parseTimeDiff(swimmingTimeDiff.value)));
            }
        }

        window.addEventListener('resize', updateAllInputs);

        function isNightTime() {
            const hour = new Date().getHours();
            return hour < 6 || hour >= 20; // Consider night time between 8 PM and 6 AM
        }

        function applyTheme() {
            const body = document.body;
            const isNight = isNightTime();
            
            if (isNight) {
                body.classList.add('night-mode');
            } else {
                body.classList.remove('night-mode');
            }
        }

        applyTheme();

        setInterval(applyTheme, 60000);

        let weatherChart;
        let chartData;

        async function fetchWeatherData(dateStr = null) {
            try {
                // For debugging
                console.log("fetchWeatherData called with dateStr:", dateStr);
                
                let targetDate, formattedDate;
                
                // Handle different formats of input
                if (dateStr) {
                    if (dateStr.includes('-')) {
                        // It's already in YYYY-MM-DD format
                        formattedDate = dateStr;
                        
                        // Manually create date to avoid timezone issues
                        const [year, month, day] = dateStr.split('-').map(Number);
                        targetDate = new Date(year, month - 1, day);
                        
                        console.log("Created date from components:", targetDate.toDateString());
                    } else {
                        // It's a Date object or other format
                        targetDate = new Date(dateStr);
                        formattedDate = formatDate(targetDate);
                    }
                } else {
                    // No date provided, use current date
                    targetDate = new Date();
                    formattedDate = formatDate(targetDate);
                }
                
                console.log("Target date:", targetDate.toDateString());
                console.log("Formatted date for API:", formattedDate);
                
                // Update the forecast title
                const today = new Date();
                if (formatDate(targetDate) === formatDate(today)) {
                    forecastTitle.textContent = "Today's Weather Forecast";
                } else {
                    forecastTitle.textContent = formatDateForDisplay(targetDate);
                }
                
                // Updated coordinates for Mission Bay, San Francisco
                const response = await axios.get(`https://api.open-meteo.com/v1/forecast?latitude=37.7749&longitude=-122.3890&hourly=temperature_2m,cloudcover,windspeed_10m,precipitation_probability&timezone=America/Los_Angeles&start_date=${formattedDate}&end_date=${formattedDate}&temperature_unit=fahrenheit`);
                
                const data = response.data;

                const times = data.hourly.time.map(time => new Date(time));
                const temperatures = data.hourly.temperature_2m;
                const cloudCover = data.hourly.cloudcover;
                const windSpeed = data.hourly.windspeed_10m;
                const precipProb = data.hourly.precipitation_probability;

                const filteredData = times.reduce((acc, time, index) => {
                    const hour = time.getHours();
                    if (hour >= 5 && hour <= 21) {  // 5am to 9pm
                        acc.times.push(time);
                        acc.temperatures.push(temperatures[index]);
                        acc.cloudCover.push(cloudCover[index]);
                        acc.windSpeed.push(windSpeed[index]);
                        acc.precipProb.push(precipProb[index]);
                    }
                    return acc;
                }, { times: [], temperatures: [], cloudCover: [], windSpeed: [], precipProb: [] });

                updateWeatherChart(filteredData);
                updateBestSwimTime(filteredData);
            } catch (error) {
                console.error('Error fetching weather data:', error);
            }
        }

        async function fetch16DayForecast() {
            try {
                // Use the real current date from the user's browser
                const browserDate = new Date();
                
                // Extract just the date portion and reset the time to midnight
                // This creates a clean date at the beginning of today
                const today = new Date(browserDate.getFullYear(), browserDate.getMonth(), browserDate.getDate());
                
                // Format today's date for API request
                const todayFormatted = formatDate(today);
                
                // Calculate end date (15 days after today = 16 days total)
                const endDate = new Date(today);
                endDate.setDate(today.getDate() + 15);
                const endDateFormatted = formatDate(endDate);
                
                console.log(`Fetching 16-day forecast using browser date: ${browserDate}`);
                console.log(`Formatted date range: ${todayFormatted} to ${endDateFormatted}`);
                
                // Get coordinates set for San Francisco Mission Bay with explicit timezone
                const response = await axios.get(`https://api.open-meteo.com/v1/forecast?latitude=37.7749&longitude=-122.3890&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=America/Los_Angeles&start_date=${todayFormatted}&end_date=${endDateFormatted}&temperature_unit=fahrenheit`);
                
                const data = response.data;
                
                if (data.daily && data.daily.time && data.daily.weathercode) {
                    // Log the first date we received from the API to check if it matches today
                    if (data.daily.time.length > 0) {
                        console.log("First date from API:", data.daily.time[0]);
                        console.log("Expected today's date:", todayFormatted);
                        console.log("Match?", data.daily.time[0] === todayFormatted);
                    }
                    
                    // Store current selection before updating calendar
                    const currentlySelectedDate = selectedDate ? formatDate(selectedDate) : null;
                    
                    // Important: Force the first day to be today by manually adjusting the data if needed
                    // This ensures we always show exactly 16 days starting from today
                    const forcedData = {
                        time: [],
                        weathercode: [],
                        temperature_2m_max: [],
                        temperature_2m_min: [],
                        precipitation_probability_max: []
                    };
                    
                    // Find where today's data starts in the API response
                    const todayIndex = data.daily.time.findIndex(d => d === todayFormatted);
                    const actualStartIndex = todayIndex !== -1 ? todayIndex : 0;
                    
                    // Create array of expected dates (16 days from today)
                    const expectedDates = [];
                    for (let i = 0; i < 16; i++) {
                        const d = new Date(today);
                        d.setDate(d.getDate() + i);
                        expectedDates.push(formatDate(d));
                    }
                    
                    // Use the expected dates to ensure we have the right sequence
                    for (let i = 0; i < expectedDates.length; i++) {
                        const expectedDate = expectedDates[i];
                        const apiIndex = data.daily.time.findIndex(d => d === expectedDate);
                        
                        if (apiIndex !== -1) {
                            // Use data from API if we found the date
                            forcedData.time.push(data.daily.time[apiIndex]);
                            forcedData.weathercode.push(data.daily.weathercode[apiIndex]);
                            forcedData.temperature_2m_max.push(data.daily.temperature_2m_max[apiIndex]);
                            forcedData.temperature_2m_min.push(data.daily.temperature_2m_min[apiIndex]);
                            forcedData.precipitation_probability_max.push(data.daily.precipitation_probability_max[apiIndex]);
                        } else {
                            // If we don't have data for this date, use placeholder values
                            console.warn(`Missing data for expected date: ${expectedDate}`);
                            forcedData.time.push(expectedDate);
                            forcedData.weathercode.push(1); // default: partly cloudy
                            forcedData.temperature_2m_max.push(70);
                            forcedData.temperature_2m_min.push(50);
                            forcedData.precipitation_probability_max.push(0);
                        }
                    }
                    
                    console.log("Using these dates for calendar:", forcedData.time);
                    
                    if (forcedData.time.length > 0) {
                        updateWeatherCalendar(forcedData);
                        
                        // Re-highlight the selected date if it was previously set
                        if (currentlySelectedDate) {
                            highlightSelectedDayInCalendar(currentlySelectedDate);
                        }
                        
                        // Update date picker max value based on available forecast data
                        if (forcedData.time.length > 0) {
                            const lastAvailableDate = forcedData.time[forcedData.time.length - 1];
                            datePicker.max = lastAvailableDate;
                            console.log(`Updated date picker max to ${lastAvailableDate}`);
                        }
                    } else {
                        console.error("No dates found for the forecast");
                        document.getElementById('weather-calendar').innerHTML = 
                            '<p class="col-span-full text-center">Unable to find required dates in the forecast data. Please try refreshing the page.</p>';
                    }
                }
            } catch (error) {
                console.error('Error fetching 16-day forecast:', error);
                document.getElementById('weather-calendar').innerHTML = 
                    '<p class="col-span-full text-center">Unable to fetch weather forecast calendar. Please try again later.</p>';
            }
        }

        function updateWeatherChart(data) {
            const ctx = document.getElementById('weatherChart').getContext('2d');
            const isMobile = window.innerWidth <= 640;

            if (weatherChart) {
                weatherChart.destroy();
            }

            chartData = data;

            const chartColors = {
                temperature: 'rgb(255, 99, 132)',
                cloudCover: 'rgb(54, 162, 235)',
                windSpeed: 'rgb(75, 192, 192)',
                precipProb: 'rgb(153, 102, 255)'
            };

            const legendItems = document.querySelectorAll('#mobile-legend .rounded-full');
            legendItems[0].style.backgroundColor = chartColors.temperature;
            legendItems[1].style.backgroundColor = chartColors.cloudCover;
            legendItems[2].style.backgroundColor = chartColors.windSpeed;
            legendItems[3].style.backgroundColor = chartColors.precipProb;

            weatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.times.map(formatTime),
                    datasets: [
                        {
                            label: 'Temperature (¬∞F)',
                            data: data.temperatures,
                            borderColor: chartColors.temperature,
                            backgroundColor: chartColors.temperature + '33',
                            pointBackgroundColor: chartColors.temperature,
                            yAxisID: 'y-temperature',
                        },
                        {
                            label: 'Cloud Cover (%)',
                            data: data.cloudCover,
                            borderColor: chartColors.cloudCover,
                            backgroundColor: chartColors.cloudCover + '33',
                            pointBackgroundColor: chartColors.cloudCover,
                            yAxisID: 'y-percentage',
                        },
                        {
                            label: 'Wind Speed (mph)',
                            data: data.windSpeed.map(speed => Number((speed * 0.621371).toFixed(1))),
                            borderColor: chartColors.windSpeed,
                            backgroundColor: chartColors.windSpeed + '33',
                            pointBackgroundColor: chartColors.windSpeed,
                            yAxisID: 'y-wind',
                        },
                        {
                            label: 'Precipitation Probability (%)',
                            data: data.precipProb,
                            borderColor: chartColors.precipProb,
                            backgroundColor: chartColors.precipProb + '33',
                            pointBackgroundColor: chartColors.precipProb,
                            yAxisID: 'y-percentage',
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: isMobile ? 1 : 2,
                    plugins: {
                        legend: {
                            display: !isMobile,
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'line',
                                boxWidth: 40,
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    const timeStr = tooltipItems[0].label;
                                    const [hours, minutes] = timeStr.split(':').map(Number);
                                    const ampm = hours >= 12 ? 'PM' : 'AM';
                                    const hours12 = hours % 12 || 12;
                                    return `${hours12}:${minutes.toString().padStart(2, '0')} ${ampm}`;
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1);
                                        if (context.dataset.label === 'Wind Speed (mph)') {
                                            label += ' mph';
                                        } else if (context.dataset.label.includes('%')) {
                                            label += '%';
                                        } else if (context.dataset.label.includes('¬∞F')) {
                                            label += '¬∞F';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 5,
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                callback: function(val, index) {
                                    const time = this.getLabelForValue(val);
                                    const [hours, minutes] = time.split(':');
                                    const hourNum = parseInt(hours);
                                    const amPm = hourNum >= 12 ? 'P' : 'A';
                                    const hour12 = hourNum % 12 || 12;

                                    if (isMobile) {
                                        const displayHours = [5, 7, 9, 11, 13, 15, 17, 19, 21];
                                        if (displayHours.includes(hourNum)) {
                                            return `${hour12}${amPm}`;
                                        }
                                        return '';
                                    } else {
                                        return `${hour12}:${minutes}${amPm}`;
                                    }
                                },
                                maxRotation: 0,
                                font: {
                                    size: 9
                                }
                            }
                        },
                        'y-temperature': {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞F)'
                            },
                        },
                        'y-percentage': {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Cloud Cover & Precipitation (%)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            }
                        },
                        'y-wind': {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wind Speed (mph)'
                            },
                            min: 0,
                            max: 30,
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                },
            });
        }

        function updateBestSwimTime(data) {
            let scores = [];

            for (let i = 0; i < data.times.length; i++) {
                const hour = data.times[i].getHours();
                if (hour >= 6 && hour <= 20) {
                    const tempScore = data.temperatures[i] * 2;
                    const rainScore = 100 - data.precipProb[i];
                    const cloudScore = (100 - data.cloudCover[i]) / 2;
                    const windScore = (20 - data.windSpeed[i]) / 2;
                    
                    const totalScore = tempScore + rainScore + cloudScore + windScore;
                    scores.push({ time: data.times[i], score: totalScore });
                }
            }

            scores.sort((a, b) => b.score - a.score);

            // Handle case when there aren't enough data points
            if (scores.length < 2) {
                document.getElementById('best-time-info-1').innerHTML = '<li>Not enough data for this date</li>';
                document.getElementById('best-time-info-2').innerHTML = '<li>Not enough data for this date</li>';
                return;
            }

            const bestTime1 = scores[0].time;
            const bestTime2 = scores[1].time;

            function createInfoList(time) {
                const i = data.times.findIndex(t => t.getTime() === time.getTime());
                const hours = time.getHours();
                const minutes = time.getMinutes().toString().padStart(2, '0');
                const ampm = hours >= 12 ? 'pm' : 'am';
                const hours12 = hours % 12 || 12;
                
                // Create the formatted time with day information
                let formattedTime = `${hours12}:${minutes}${ampm}`;
                
                // Add day information based on the selected date (not the time's date)
                // This ensures consistency across the UI
                let dateToDisplay = selectedDate || new Date();
                
                // Format the display date to match the current selected date
                const formattedMonth = dateToDisplay.toLocaleString('default', { month: 'short' });
                const formattedDay = dateToDisplay.getDate();
                formattedTime += ` on ${formattedMonth} ${formattedDay}`;

                const windSpeedMph = (data.windSpeed[i] * 0.621371).toFixed(1);

                return `
                    <li>‚è∞ ${formattedTime}</li>
                    <li>üå°Ô∏è ${data.temperatures[i].toFixed(1)}¬∞F</li>
                    <li>üåß ${data.precipProb[i]}% chance</li>
                    <li>‚òÅÔ∏è ${data.cloudCover[i]}% cover</li>
                    <li>üå¨Ô∏è ${windSpeedMph} mph</li>
                `;
            }

            document.getElementById('best-time-info-1').innerHTML = createInfoList(bestTime1);
            document.getElementById('best-time-info-2').innerHTML = createInfoList(bestTime2);
        }

        function updateWeatherCalendar(dailyData) {
            const calendarContainer = document.getElementById('weather-calendar');
            calendarContainer.innerHTML = '';
            
            // Map weather codes to emojis and descriptions
            const weatherEmojis = {
                0: { emoji: '‚òÄÔ∏è', description: 'Clear sky' },
                1: { emoji: 'üå§Ô∏è', description: 'Mainly clear' },
                2: { emoji: '‚õÖ', description: 'Partly cloudy' },
                3: { emoji: '‚òÅÔ∏è', description: 'Overcast' },
                45: { emoji: 'üå´Ô∏è', description: 'Fog' },
                48: { emoji: 'üå´Ô∏è', description: 'Depositing rime fog' },
                51: { emoji: 'üå¶Ô∏è', description: 'Light drizzle' },
                53: { emoji: 'üå¶Ô∏è', description: 'Moderate drizzle' },
                55: { emoji: 'üåßÔ∏è', description: 'Dense drizzle' },
                56: { emoji: 'üå®Ô∏è', description: 'Light freezing drizzle' },
                57: { emoji: 'üå®Ô∏è', description: 'Dense freezing drizzle' },
                61: { emoji: 'üåßÔ∏è', description: 'Slight rain' },
                63: { emoji: 'üåßÔ∏è', description: 'Moderate rain' },
                65: { emoji: 'üåßÔ∏è', description: 'Heavy rain' },
                66: { emoji: 'üå®Ô∏è', description: 'Light freezing rain' },
                67: { emoji: 'üå®Ô∏è', description: 'Heavy freezing rain' },
                71: { emoji: '‚ùÑÔ∏è', description: 'Slight snow fall' },
                73: { emoji: '‚ùÑÔ∏è', description: 'Moderate snow fall' },
                75: { emoji: '‚ùÑÔ∏è', description: 'Heavy snow fall' },
                77: { emoji: '‚ùÑÔ∏è', description: 'Snow grains' },
                80: { emoji: 'üå¶Ô∏è', description: 'Slight rain showers' },
                81: { emoji: 'üåßÔ∏è', description: 'Moderate rain showers' },
                82: { emoji: 'üåßÔ∏è', description: 'Violent rain showers' },
                85: { emoji: 'üå®Ô∏è', description: 'Slight snow showers' },
                86: { emoji: 'üå®Ô∏è', description: 'Heavy snow showers' },
                95: { emoji: '‚õàÔ∏è', description: 'Thunderstorm' },
                96: { emoji: '‚õàÔ∏è', description: 'Thunderstorm with slight hail' },
                99: { emoji: '‚õàÔ∏è', description: 'Thunderstorm with heavy hail' },
            };
            
            // Format for display
            function formatCalendarDate(dateObj) {
                const dayOfWeek = getDayOfWeek(dateObj).substring(0, 3);
                const month = dateObj.toLocaleString('default', { month: 'short' });
                const day = dateObj.getDate();
                return `${dayOfWeek}, ${month} ${day}`;
            }
            
            // Today's date for comparison
            const today = new Date();
            const todayStr = formatDate(today);
            
            // Currently selected date (if any)
            const selectedDateStr = selectedDate ? formatDate(selectedDate) : null;
            
            // Create a calendar cell for each day
            for (let i = 0; i < dailyData.time.length && i < 16; i++) {
                const dateStr = dailyData.time[i];
                const weatherCode = dailyData.weathercode[i];
                const maxTemp = dailyData.temperature_2m_max[i];
                const minTemp = dailyData.temperature_2m_min[i];
                const precipProb = dailyData.precipitation_probability_max[i];
                
                const weatherInfo = weatherEmojis[weatherCode] || { emoji: '‚ùì', description: 'Unknown' };
                
                // Create date object to get day and month
                const dateObj = new Date(dateStr);
                
                // Use our custom formatter for more consistent display
                const formattedDate = formatCalendarDate(dateObj);
                
                // Create calendar cell
                const cell = document.createElement('div');
                cell.className = 'bg-gray-50 rounded p-2 text-center hover:bg-gray-100 cursor-pointer';
                cell.dataset.date = dateStr; // Store date for selection highlighting
                
                // Add borders based on selection status
                if (dateStr === selectedDateStr) {
                    // Selected date gets green border
                    cell.className += ' border-2 border-green-500';
                } else if (dateStr === todayStr) {
                    // Today gets blue border (if not selected)
                    cell.className += ' border-2 border-blue-500';
                }
                
                cell.innerHTML = `
                    <div class="text-xs font-semibold">${formattedDate}</div>
                    <div class="text-3xl my-1" title="${weatherInfo.description}">${weatherInfo.emoji}</div>
                    <div class="text-xs">
                        <span class="text-red-500">${Math.round(maxTemp)}¬∞F</span> / 
                        <span class="text-blue-500">${Math.round(minTemp)}¬∞F</span>
                    </div>
                    <div class="text-xs ${precipProb > 30 ? 'text-blue-600 font-semibold' : 'text-gray-500'}">
                        ${precipProb}% üíß
                    </div>
                `;
                
                // Add click handler to go to that date
                cell.addEventListener('click', () => {
                    datePicker.value = dateStr;
                    handleDateChange();
                });
                
                calendarContainer.appendChild(cell);
            }
        }

        window.addEventListener('resize', () => {
            if (chartData) {
                updateWeatherChart(chartData);
            }
        });

        // Function to update the image
        async function updateGGBImage() {
            const img = document.getElementById('ggb-image');
            if (!img) return;
            
            img.classList.add('loading');

            try {
                // Cache-busting technique 1: Use GitHub API to get the latest file content
                // This bypasses GitHub's raw content caching
                const apiUrl = 'https://api.github.com/repos/danielraffel/ggb/contents/ggb.screenshot.png';
                const apiResponse = await fetch(apiUrl, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        // Cache-busting technique 2: Add no-cache header to API request
                        'Cache-Control': 'no-cache'
                    }
                });
                const fileData = await apiResponse.json();

                if (!fileData.content) {
                    throw new Error('No content found in the API response');
                }

                // Cache-busting technique 3: Decode and use the Base64 content directly
                // This ensures we're using the exact data returned by the API, not a cached version
                const byteCharacters = atob(fileData.content);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {type: 'image/png'});

                // Cache-busting technique 4: Use a Blob URL
                // This creates a unique URL for each new image version
                const objectURL = URL.createObjectURL(blob);
                
                // Create a new Image object to preload the image
                const tempImg = new Image();
                tempImg.onload = function() {
                    console.log('New image loaded, updating src');
                    // Cache-busting technique 5: Update image src with the new Blob URL
                    // This ensures the browser displays the new image, not a cached version
                    img.src = objectURL;
                    URL.revokeObjectURL(img.src);
                    img.classList.remove('loading');
                };
                tempImg.onerror = function() {
                    console.error('Error loading new image');
                    img.classList.remove('loading');
                };
                tempImg.src = objectURL;
            } catch (error) {
                console.error('Error fetching image:', error);
                img.classList.remove('loading');
            }
        }

        // Add this function to provide subtle UX feedback
        function provideFeedback(element) {
            console.log('Providing feedback for', element.id);
            element.classList.remove('animate-blink');
            void element.offsetWidth; // Trigger reflow
            element.classList.add('animate-blink');
            setTimeout(() => {
                element.classList.remove('animate-blink');
            }, 1500);
        }
    </script>
</body>
</html>